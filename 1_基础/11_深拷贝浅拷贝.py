""" 
  当我们复制列表和字典的时候   
  因为是赋值 所以会新开辟一块内存空间  变量指向该内存地址
  但是其内部成员是引用地址的 也就是复制的也是成员的地址
  那么如果成员又是一个 列表或字典的话
  修改会互相影响
  这就是默认的浅拷贝

  而深拷贝就是 如果复制的成员是列表或字典的话 就再开辟一块内存空间 
  再把赋值对应的成员值

  注意python中的深拷贝 虽然会给列表或字典数据类型的成员重新开辟一块内存空间
  但是默认列表内的成员地址 还是指向同一块内存地址
  但是写操作的时候 会重新开辟一块内存空间
  这是一种优化  如果只是读操作 我就不需要开辟内存空间 

"""

# 注意python中没有变量提升的概念 所以必须先定义后使用
list1 = [1,2,3,4,5,6,[7,8,9]]
# copy复制  会重新开辟一块内存空间绑定list2 但是内部的成员地址 是复制过来的
list2 = list1.copy()

print(list2)#[1, 2, 3, 4, 5, 6, [7, 8, 9]]
print(id(list1),id(list2))#2171003615168 2171003895104

# 复制地址  指向同一个地址   浅拷贝
print(id(list1[0]),id(list2[0]))#140723200972448 140723200972448
print(id(list1[6][2]),id(list2[6][2]))#140723200972704 140723200972704

# 列表内 存的是地址  引用地址  所以互相影响
list1[6][2] = 99
print(list1[6][2],list2[6][2])#99 99
print(id(list1[6][2]),id(list2[6][2]))#140723200975584 140723200975584



# 深拷贝  独立  重新开辟一块内存空间  不会互相影响 我修改值 只是修改自己容器存的地址而已
# 用标准库  copy 的deepcopy方法
import copy
list1 = [1,2,3,4,5,6,[7,8,9]]
list2 = copy.deepcopy(list1)
print(list2)#[1, 2, 3, 4, 5, 6, [7, 8, 9]]
print(id(list1[0]),id(list2[0]))
print(id(list1[6]),id(list2[6]))#2520153299840 2520153871552
print(id(list1[6][2]),id(list2[6][2]))#140723200972704 140723200972704
list1[6][2] = 99
print(list1[6][2],list2[6][2])#99 9
print(id(list1[6][2]),id(list2[6][2]))#140723200975584 140723200972704
